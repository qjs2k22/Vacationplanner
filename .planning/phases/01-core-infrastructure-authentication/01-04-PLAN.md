---
phase: 01-core-infrastructure-authentication
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/db/queries/trips.ts
  - src/app/api/trips/route.ts
  - src/app/api/trips/[id]/route.ts
  - src/lib/validations.ts
autonomous: true

must_haves:
  truths:
    - "User can create a trip via POST /api/trips"
    - "User can only access their own trips"
    - "User can update trip details via PATCH /api/trips/[id]"
    - "User can delete a trip via DELETE /api/trips/[id]"
    - "User can fetch all their trips via GET /api/trips"
  artifacts:
    - path: "src/db/queries/trips.ts"
      provides: "Database query functions for trips"
      exports: ["createTrip", "getTripsForUser", "getTripById", "updateTrip", "deleteTrip"]
    - path: "src/app/api/trips/route.ts"
      provides: "API routes for trip list and creation"
      exports: ["GET", "POST"]
    - path: "src/app/api/trips/[id]/route.ts"
      provides: "API routes for single trip operations"
      exports: ["GET", "PATCH", "DELETE"]
    - path: "src/lib/validations.ts"
      provides: "Zod schemas for request validation"
      contains: "createTripSchema"
  key_links:
    - from: "src/app/api/trips/route.ts"
      to: "src/db/queries/trips.ts"
      via: "query function imports"
      pattern: "import.*queries/trips"
    - from: "src/app/api/trips/route.ts"
      to: "@clerk/nextjs/server"
      via: "auth() for userId"
      pattern: "await auth\\(\\)"
    - from: "src/db/queries/trips.ts"
      to: "src/db/index.ts"
      via: "db client import"
      pattern: "import.*db.*from"
---

<objective>
Implement Trip CRUD operations with database queries and API routes.

Purpose: Enable users to create, read, update, and delete trips through a REST API. This covers TRIP-01 through TRIP-05 requirements. All operations are scoped to the authenticated user (defense-in-depth at data layer per RESEARCH.md).

Output: Working API endpoints for trip management with proper authorization checks at every layer.
</objective>

<execution_context>
@/Users/quentonschneider/.claude/get-shit-done/workflows/execute-plan.md
@/Users/quentonschneider/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-infrastructure-authentication/01-RESEARCH.md
@.planning/phases/01-core-infrastructure-authentication/01-02-SUMMARY.md
@.planning/phases/01-core-infrastructure-authentication/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zod Validation Schemas</name>
  <files>
    src/lib/validations.ts
  </files>
  <action>
Create src/lib/validations.ts with Zod schemas for API request validation.

```typescript
// src/lib/validations.ts
import { z } from "zod";

// Schema for creating a new trip
export const createTripSchema = z.object({
  name: z
    .string()
    .min(1, "Trip name is required")
    .max(255, "Trip name must be 255 characters or less"),
  description: z
    .string()
    .max(1000, "Description must be 1000 characters or less")
    .optional()
    .nullable(),
  startDate: z
    .string()
    .datetime({ message: "Invalid start date format. Use ISO 8601 format." }),
  endDate: z
    .string()
    .datetime({ message: "Invalid end date format. Use ISO 8601 format." }),
}).refine(
  (data) => new Date(data.startDate) <= new Date(data.endDate),
  {
    message: "End date must be after or equal to start date",
    path: ["endDate"],
  }
);

// Schema for updating a trip (all fields optional)
export const updateTripSchema = z.object({
  name: z
    .string()
    .min(1, "Trip name is required")
    .max(255, "Trip name must be 255 characters or less")
    .optional(),
  description: z
    .string()
    .max(1000, "Description must be 1000 characters or less")
    .optional()
    .nullable(),
  startDate: z
    .string()
    .datetime({ message: "Invalid start date format. Use ISO 8601 format." })
    .optional(),
  endDate: z
    .string()
    .datetime({ message: "Invalid end date format. Use ISO 8601 format." })
    .optional(),
}).refine(
  (data) => {
    // Only validate if both dates are provided
    if (data.startDate && data.endDate) {
      return new Date(data.startDate) <= new Date(data.endDate);
    }
    return true;
  },
  {
    message: "End date must be after or equal to start date",
    path: ["endDate"],
  }
);

// Type inference from schemas
export type CreateTripInput = z.infer<typeof createTripSchema>;
export type UpdateTripInput = z.infer<typeof updateTripSchema>;
```
  </action>
  <verify>
    # Verify schemas are exported
    grep -q "export const createTripSchema" src/lib/validations.ts
    grep -q "export const updateTripSchema" src/lib/validations.ts

    # Verify date validation refinement
    grep -q "refine" src/lib/validations.ts
  </verify>
  <done>
    Zod validation schemas created for trip creation and updates. Date range validation ensures endDate >= startDate. Type inference available for TypeScript.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Database Query Functions</name>
  <files>
    src/db/queries/trips.ts
  </files>
  <action>
Create src/db/queries/trips.ts with CRUD functions.

CRITICAL (from RESEARCH.md Pattern 1): Every query function MUST verify the userId matches the requesting user. This is defense-in-depth - even if middleware is bypassed, data access is still protected.

```typescript
// src/db/queries/trips.ts
import { eq, and, desc } from 'drizzle-orm';
import { db, trips, type Trip, type NewTrip } from '@/db';

/**
 * Create a new trip for a user
 */
export async function createTrip(
  userId: string,
  data: {
    name: string;
    description?: string | null;
    startDate: Date;
    endDate: Date;
  }
): Promise<Trip> {
  const [trip] = await db
    .insert(trips)
    .values({
      userId,
      name: data.name,
      description: data.description,
      startDate: data.startDate,
      endDate: data.endDate,
    })
    .returning();

  return trip;
}

/**
 * Get all trips for a user, ordered by start date descending
 */
export async function getTripsForUser(userId: string): Promise<Trip[]> {
  return db
    .select()
    .from(trips)
    .where(eq(trips.userId, userId))
    .orderBy(desc(trips.startDate));
}

/**
 * Get a single trip by ID, verifying ownership
 * Returns null if trip doesn't exist or doesn't belong to user
 */
export async function getTripById(
  tripId: string,
  userId: string
): Promise<Trip | null> {
  const [trip] = await db
    .select()
    .from(trips)
    .where(
      and(
        eq(trips.id, tripId),
        eq(trips.userId, userId) // Ownership check - defense in depth
      )
    );

  return trip ?? null;
}

/**
 * Update a trip, verifying ownership
 * Returns updated trip or null if not found/not owned
 */
export async function updateTrip(
  tripId: string,
  userId: string,
  data: Partial<{
    name: string;
    description: string | null;
    startDate: Date;
    endDate: Date;
  }>
): Promise<Trip | null> {
  const [updated] = await db
    .update(trips)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(
      and(
        eq(trips.id, tripId),
        eq(trips.userId, userId) // Ownership check - defense in depth
      )
    )
    .returning();

  return updated ?? null;
}

/**
 * Delete a trip, verifying ownership
 * Returns true if deleted, false if not found/not owned
 */
export async function deleteTrip(
  tripId: string,
  userId: string
): Promise<boolean> {
  const result = await db
    .delete(trips)
    .where(
      and(
        eq(trips.id, tripId),
        eq(trips.userId, userId) // Ownership check - defense in depth
      )
    )
    .returning({ id: trips.id });

  return result.length > 0;
}
```
  </action>
  <verify>
    # Verify all CRUD functions exported
    grep -q "export async function createTrip" src/db/queries/trips.ts
    grep -q "export async function getTripsForUser" src/db/queries/trips.ts
    grep -q "export async function getTripById" src/db/queries/trips.ts
    grep -q "export async function updateTrip" src/db/queries/trips.ts
    grep -q "export async function deleteTrip" src/db/queries/trips.ts

    # Verify ownership checks in all write operations
    grep -c "userId" src/db/queries/trips.ts | grep -q "[3-9]"
  </verify>
  <done>
    Database query functions created with ownership verification on all operations. CRUD: createTrip, getTripsForUser, getTripById, updateTrip, deleteTrip.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create API Routes for Trips</name>
  <files>
    src/app/api/trips/route.ts
    src/app/api/trips/[id]/route.ts
  </files>
  <action>
Create API routes for trip operations.

src/app/api/trips/route.ts - List and create trips:
```typescript
// src/app/api/trips/route.ts
import { auth } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';
import { createTrip, getTripsForUser } from '@/db/queries/trips';
import { createTripSchema } from '@/lib/validations';

/**
 * GET /api/trips - Get all trips for authenticated user
 */
export async function GET() {
  const { userId } = await auth();

  if (!userId) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const trips = await getTripsForUser(userId);
    return NextResponse.json(trips);
  } catch (error) {
    console.error('Failed to fetch trips:', error);
    return NextResponse.json(
      { error: 'Failed to fetch trips' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/trips - Create a new trip
 */
export async function POST(req: Request) {
  const { userId } = await auth();

  if (!userId) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const body = await req.json();
    const validated = createTripSchema.safeParse(body);

    if (!validated.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validated.error.flatten() },
        { status: 400 }
      );
    }

    const { name, description, startDate, endDate } = validated.data;

    const trip = await createTrip(userId, {
      name,
      description,
      startDate: new Date(startDate),
      endDate: new Date(endDate),
    });

    return NextResponse.json(trip, { status: 201 });
  } catch (error) {
    console.error('Failed to create trip:', error);
    return NextResponse.json(
      { error: 'Failed to create trip' },
      { status: 500 }
    );
  }
}
```

src/app/api/trips/[id]/route.ts - Single trip operations:
```typescript
// src/app/api/trips/[id]/route.ts
import { auth } from '@clerk/nextjs/server';
import { NextResponse } from 'next/server';
import { getTripById, updateTrip, deleteTrip } from '@/db/queries/trips';
import { updateTripSchema } from '@/lib/validations';

type RouteParams = {
  params: Promise<{ id: string }>;
};

/**
 * GET /api/trips/[id] - Get a single trip
 */
export async function GET(
  req: Request,
  { params }: RouteParams
) {
  const { userId } = await auth();
  const { id } = await params;

  if (!userId) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const trip = await getTripById(id, userId);

    if (!trip) {
      return NextResponse.json(
        { error: 'Trip not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(trip);
  } catch (error) {
    console.error('Failed to fetch trip:', error);
    return NextResponse.json(
      { error: 'Failed to fetch trip' },
      { status: 500 }
    );
  }
}

/**
 * PATCH /api/trips/[id] - Update a trip
 */
export async function PATCH(
  req: Request,
  { params }: RouteParams
) {
  const { userId } = await auth();
  const { id } = await params;

  if (!userId) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const body = await req.json();
    const validated = updateTripSchema.safeParse(body);

    if (!validated.success) {
      return NextResponse.json(
        { error: 'Validation failed', details: validated.error.flatten() },
        { status: 400 }
      );
    }

    // Build update data, converting dates if provided
    const updateData: Parameters<typeof updateTrip>[2] = {};

    if (validated.data.name !== undefined) {
      updateData.name = validated.data.name;
    }
    if (validated.data.description !== undefined) {
      updateData.description = validated.data.description;
    }
    if (validated.data.startDate !== undefined) {
      updateData.startDate = new Date(validated.data.startDate);
    }
    if (validated.data.endDate !== undefined) {
      updateData.endDate = new Date(validated.data.endDate);
    }

    const trip = await updateTrip(id, userId, updateData);

    if (!trip) {
      return NextResponse.json(
        { error: 'Trip not found' },
        { status: 404 }
      );
    }

    return NextResponse.json(trip);
  } catch (error) {
    console.error('Failed to update trip:', error);
    return NextResponse.json(
      { error: 'Failed to update trip' },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/trips/[id] - Delete a trip
 */
export async function DELETE(
  req: Request,
  { params }: RouteParams
) {
  const { userId } = await auth();
  const { id } = await params;

  if (!userId) {
    return NextResponse.json(
      { error: 'Unauthorized' },
      { status: 401 }
    );
  }

  try {
    const deleted = await deleteTrip(id, userId);

    if (!deleted) {
      return NextResponse.json(
        { error: 'Trip not found' },
        { status: 404 }
      );
    }

    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error('Failed to delete trip:', error);
    return NextResponse.json(
      { error: 'Failed to delete trip' },
      { status: 500 }
    );
  }
}
```

Note: RouteParams uses Promise<{ id: string }> because Next.js 15 changed params to be async.
  </action>
  <verify>
    # Verify /api/trips route exports GET and POST
    grep -q "export async function GET" src/app/api/trips/route.ts
    grep -q "export async function POST" src/app/api/trips/route.ts

    # Verify /api/trips/[id] route exports GET, PATCH, DELETE
    grep -q "export async function GET" "src/app/api/trips/[id]/route.ts"
    grep -q "export async function PATCH" "src/app/api/trips/[id]/route.ts"
    grep -q "export async function DELETE" "src/app/api/trips/[id]/route.ts"

    # Verify auth checks in all routes
    grep -c "await auth()" src/app/api/trips/route.ts | grep -q "2"
    grep -c "await auth()" "src/app/api/trips/[id]/route.ts" | grep -q "3"

    # Build should succeed
    npm run build
  </verify>
  <done>
    API routes created for full trip CRUD:
    - GET /api/trips - List user's trips
    - POST /api/trips - Create new trip
    - GET /api/trips/[id] - Get single trip
    - PATCH /api/trips/[id] - Update trip
    - DELETE /api/trips/[id] - Delete trip
    All routes verify authentication and ownership.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds
2. Validation schemas exist with date range checking
3. Database query functions include ownership verification
4. API routes check authentication and use query functions
5. All CRUD operations are covered (Create, Read, Update, Delete)
</verification>

<success_criteria>
- POST /api/trips creates trip and returns 201
- GET /api/trips returns user's trips only
- GET /api/trips/[id] returns single trip or 404
- PATCH /api/trips/[id] updates trip or returns 404
- DELETE /api/trips/[id] deletes trip and returns 204
- All routes return 401 for unauthenticated requests
- Validation errors return 400 with details
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure-authentication/01-04-SUMMARY.md`
</output>
